Control signals :
---------
stage 1
---------
IR_LATCH_EN 
NPC_LATCH_EN 
---------
stage 2
---------
RF_RD1_EN
RF_RD2_EN
DEC_OUTREG_EN
IS_I_TYPE
ZERO_PADDING
---------
stage 3  
---------
MUXA_SEL 
MUXB_SEL 
EXE_OUTREG_EN instead of ALU_OUTREG_EN
FLAGS_RST
EQ_COND 
JUMP_EN 
--------
stage 4
--------
DRAM_WE 
BYTE_LEN
MEM_OUTREG_EN
PC_LATCH_EN 
ZERO_PADDING
MEM_OUT
--------
stage 5
-------
WB_MUX_SEL 
JAL_MUX_SEL
RF_WR_EN 
-------

Instructions [58 for the pro version, 53 on pdf] :

-------------------------------------------------------------------
nop [Idles one cycle]                       |         
-------------------------------------------------------------------
j	[PC <-- PC + imm26]		  |   -- ADD with unsigned
--------------------------------------------------------------------
jal [R31 <-- PC + 4; PC <-- PC + imm26]     |   -- ADD 
---------------------------------------------------------------------
beqz [if (R[rega] == 0) PC <-- PC + imm16]	  |   -- ADD
---------------------------------------------------------------------
bnez [if (R[rega] != 0) PC <-- PC + imm16]  |   --ADD
---------------------------------------------------------------------
addi [R[regb] <-- R[rega] + imm16]          |   --ADD
---------------------------------------------------------------------
addui [R[regb] <-- R[rega] + uimm16]        |   --ADD
---------------------------------------------------------------------
subi [R[regb] <-- R[rega] - imm16]          |   --SUB
---------------------------------------------------------------------
subui [R[regb] <-- R[rega] - uimm16]        |   --SUB
---------------------------------------------------------------------
andi  [R[regb] <-- R[rega] & uimm16]		|   --AND
---------------------------------------------------------------------
ori   [R[regb] <-- R[rega] | uimm16]	    |	--OR
---------------------------------------------------------------------
xori  [R[regb] <-- R[rega] XOR uimm16]      |   --XOR
---------------------------------------------------------------------
lhi   [R[regb] <-- imm16 ## 0^16]           |   --SHIFT
---------------------------------------------------------------------
jr  [PC <-- R[rega] ]                       |   -- ADD 0 or BYPASS
---------------------------------------------------------------------
jalr [R31 <-- PC + 4; PC <-- R[rega]]       |   -- ADD 0 or BYPASS
---------------------------------------------------------------------
slli [R[regb] <-- R[rega] << uimm16_27..31] |   --SHIFT
---------------------------------------------------------------------
srli [R[regb] <-- R[rega] >> uimm16_27..31] |   --SHIFT
-----------------------------------------------------------------------------------------------
srai [R[regb] <-- (R[rega]_31)^uimm16 ## (R[rega]>>uimm16)_uimm16..31] |   --ARITH SHIFT imm
-----------------------------------------------------------------------------------------------
seqi [if (R[rega] == imm16) R[regb] <-- 1 else R[regb] <-- 0]  |  --COMP (eq)
-------------------------------------------------------------------------------------       
snei [if (R[rega] != imm16) R[regb] <-- 1 else R[regb] <-- 0]  |  --COMP (diff)
-------------------------------------------------------------------------------------
slti [if (R[rega] < imm16) R[regb] <-- 1 else R[regb] <-- 0]   |  --COMP (Less than)
-------------------------------------------------------------------------------------
sgti [if (R[rega] > imm16) R[regb] <-- 1 else R[regb] <-- 0]   |  --COMP (GREATER than)
--------------------------------------------------------------------------------------
slei [if (R[rega] <= imm16) R[regb] <-- 1 else R[regb] <-- 0]  |   --COMP (Less eq)
------------------------------------------------------------------------------------
sgei [if (R[rega] >= imm16) R[regb] <-- 1 else R[regb] <-- 0]  |   --COMP (great eq)
-----------------------------------------------------------------------------------------------------------
lb [R[regb] <-- (sign extended) M[imm16 + R[rega]]]	| Requires a sign extension in MEM stage--ADD
-----------------------------------------------------------------------------------------------------------
lh [R[regb] <-- (sign extended) M[imm16 + R[rega]]] | Requires a sign extension in MEM stage--ADD
-----------------------------------------------------------------------------------------------------------
lw  [R[regb] <-- M[imm16 + R[rega]]]  | --ADD
-------------------------------------------------------------------------------------------------------
lbu [R[regb] <-- 0^24 ## M[imm16 + R[rega]]]  | Requires a sign extension in MEM stage (add zeros)--ADD
--------------------------------------------------------------------------------------------------------
lhu [R[regb] <-- 0^16 ## M[imm16 + R[rega]]]  | Requires a sign extension in MEM stage (add zeros)--ADD
------------------------------------------------------------------------------------------------------
sb 	[M[imm16 + R[rega]] <--8 R[regb]_24..31]  | --ADD (signed) need an extra control signal
------------------------------------------------------------------------------------------------------
sh  [M[imm16 + R[rega]] <--16 R[regb]_16..31] | --ADD (signed) need an extra control signal
------------------------------------------------------------------------------------------------------
sw [M[imm16 + R[rega]] <-- R[regb]]  | --ADD (signed) need an extra control signal
------------------------------------------------------------------------------------------------------
sltui [if (R[rega] < uimm16) R[regb] <-- 1 else R[regb] <-- 0] |   --COMP unsigned
------------------------------------------------------------------------------------------------------
sgtui [if (R[rega] > uimm16) R[regb] <-- 1 else R[regb] <-- 0] |   --COMP unsigned
------------------------------------------------------------------------------------------------------
sleui [if (R[rega] <= uimm16) R[regb] <-- 1 else R[regb] <-- 0] | --COMP unsigned
------------------------------------------------------------------------------------------------------
sgeui [if (R[rega] >= uimm16) R[regb] <-- 1 else R[regb] <-- 0] | --COMP unsigned
------------------------------------------------------------------------------------------------------
sll [R[regc] <-- R[rega] << R[regb]_27..31]  | 	 --SHIFT LOGIC
------------------------------------------------------------------------------------------------------
srl [R[regc] <-- R[rega] >> R[regb]_27..31]  | 	 --SHIFT LOGIC
-------------------------------------------------------------------------------------------------------
sra [R[regc] <-- (R[rega]_0)^R[regb] ## (R[rega]>>R[regb])_R[regb]..31]  | --ARITH SHIFT
------------------------------------------------------------------------------------------------------
add [R[regc]<-- R[rega] + R[regb]]			 |  --ADD
---------------------------------------------------------------------
addu [R[regc] <-- R[rega] + R[regb]]         |  --ADD
---------------------------------------------------------------------
sub [R[regc] <-- R[rega] - R[regb]]	         |  --SUB
---------------------------------------------------------------------
subu [R[regc] <-- R[rega] - R[regb]]         |  --SUB
---------------------------------------------------------------------
and [R[regc] <-- R[rega] & R[regb]]			 |  --AND
---------------------------------------------------------------------
or [R[regc] <-- R[rega] | R[regb]]	         |  --OR
---------------------------------------------------------------------
xor [R[regc] <-- F[rega] XOR R[regb]]        |  --XOR
----------------------------------------------------------------------------------
seq [if (R[rega] == R[regb]) R[regc] <-- 1 else R[regc] <-- 0]	| --COMP
----------------------------------------------------------------------------------
sne [if (R[rega] != R[regb]) R[regc] <-- 1 else R[regc] <-- 0]  | --COMP
----------------------------------------------------------------------------------
slt [if (R[rega] < R[regb]) R[regc] <-- 1 else R[regc] <-- 0]   | --COMP
----------------------------------------------------------------------------------
sgt [if (R[rega] > R[regb]) R[regc] <-- 1 else R[regc] <-- 0]   | --COMP
----------------------------------------------------------------------------------
sle [if (R[rega] <= R[regb]) R[regc] <-- 1 else R[regc] <-- 0]  | --COMP
----------------------------------------------------------------------------------
sge [if (R[rega] >= R[regb]) R[regc] <-- 1 else R[regc] <-- 0]  | --COMP
----------------------------------------------------------------------------------
sltu [if (R[rega] < R[regb]) R[regc] <-- 1 else R[regc] <-- 0] 	| --COMP
----------------------------------------------------------------------------------
sgtu [if (R[rega] > R[regb]) R[regc] <-- 1 else R[regc] <-- 0]  | --COMP
----------------------------------------------------------------------------------
sleu [if (R[rega] <= R[regb]) R[regc] <-- 1 else R[regc] <-- 0]	| --COMP
----------------------------------------------------------------------------------
sgeu [if (R[rega] >= R[regb]) R[regc] <-- 1 else R[regc] <-- 0]	| --COMP
----------------------------------------------------------------------------------
mult [F[fregc] <-- F[frega] * F[fregb]] All are signed integers. | --MULT
----------------------------------------------------------------------------------
multu [F[fregc] <-- F[frega] * F[fregb]] All are unsigned integers. | --MULT unsigned
------------------------------------------------------------------------------------


